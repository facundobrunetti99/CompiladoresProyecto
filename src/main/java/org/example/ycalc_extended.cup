/*
  File Name: ycalc_extended.cup
  Extended parser for the compiler project with AST generation
  To Create: > java -cp java-cup-11b.jar java_cup.Main -package org.example -parser parser -symbols sym ycalc_extended.cup
*/

/* ----------------------Preliminary Declarations Section--------------------*/

package org.example;

import java_cup.runtime.*;
import java.util.*;
import org.example.ast.*;

parser code {:

    // Symbol table for variable declarations
    private Map<String, String> symbolTable = new HashMap<>();

    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }

        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    // Method to check if a variable is declared
    public void checkVariable(String varName) {
        if (!symbolTable.containsKey(varName)) {
            System.err.println("Error: Variable '" + varName + "' not declared");
            System.exit(1);
        }
    }

    // Method to add variable to symbol table
    public void addVariable(String varName, String type) {
        if (symbolTable.containsKey(varName)) {
            System.err.println("Error: Variable '" + varName + "' already declared");
            System.exit(1);
        }
        symbolTable.put(varName, type);
        System.out.println("Variable '" + varName + "' declared as " + type);
    }
:};

/* ------------Declaration of Terminals and Non Terminals Section----------- */

terminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN;
terminal           LBRACE, RBRACE, ASSIGN;
terminal           INT, BOOL, VOID, MAIN, RETURN;
terminal           TRUE, FALSE;
terminal           NUMBER, ID;

non terminal ProgramNode           program;
non terminal String                return_type;
non terminal MainFunctionNode      main_function;
non terminal List<DeclarationNode> declaration_list;
non terminal DeclarationNode       declaration;
non terminal List<StatementNode>   statement_list;
non terminal StatementNode         statement;
non terminal AssignmentNode        assignment;
non terminal ReturnNode            return_stmt;
non terminal ExpressionNode        expr;

/* -------------Precedence and Associatively of Terminals Section----------- */

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

/* ----------------------------Grammar Section-------------------- */

program ::= return_type:rt main_function:mf
           {:
              ProgramNode prog = new ProgramNode(rt, mf);
              System.out.println("Program parsed successfully with return type: " + rt);
              System.out.println("AST: " + prog);
              RESULT = prog;
           :}
           ;

return_type ::= INT:t
               {: RESULT = "int"; :}
               |
               BOOL:t
               {: RESULT = "bool"; :}
               |
               VOID:t
               {: RESULT = "void"; :}
               ;

main_function ::= MAIN LPAREN RPAREN LBRACE declaration_list:dl statement_list:sl RBRACE
                 {:
                    System.out.println("Main function parsed");
                    RESULT = new MainFunctionNode(dl, sl);
                 :}
                 ;

declaration_list ::= declaration_list:dl declaration:d
                    {:
                       if (dl == null) dl = new ArrayList<DeclarationNode>();
                       dl.add(d);
                       RESULT = dl;
                    :}
                    |
                    /* empty */
                    {: RESULT = new ArrayList<DeclarationNode>(); :}
                    ;

declaration ::= INT ID:name SEMI
               {:
                  addVariable((String)name, "int");
                  RESULT = new VariableDeclarationNode("int", (String)name);
               :}
               |
               BOOL ID:name SEMI
               {:
                  addVariable((String)name, "bool");
                  RESULT = new VariableDeclarationNode("bool", (String)name);
               :}
               ;

statement_list ::= statement_list:sl statement:s
                  {:
                     if (sl == null) sl = new ArrayList<StatementNode>();
                     sl.add(s);
                     RESULT = sl;
                  :}
                  |
                  /* empty */
                  {: RESULT = new ArrayList<StatementNode>(); :}
                  ;

statement ::= assignment:a
             {: RESULT = a; :}
             |
             return_stmt:r
             {: RESULT = r; :}
             ;

assignment ::= ID:name ASSIGN expr:e SEMI
              {:
                 checkVariable((String)name);
                 System.out.println("Assignment to variable: " + name);
                 RESULT = new AssignmentNode((String)name, e);
              :}
              ;

return_stmt ::= RETURN expr:e SEMI
               {:
                  System.out.println("Return statement with expression");
                  RESULT = new ReturnNode(e);
               :}
               |
               RETURN SEMI
               {:
                  System.out.println("Return statement without expression");
                  RESULT = new ReturnNode(null);
               :}
               ;

expr ::= expr:e1 PLUS expr:e2
        {:
           System.out.println("Addition operation");
           RESULT = new BinaryOpNode(e1, "+", e2);
        :}
        |
        expr:e1 MINUS expr:e2
        {:
           System.out.println("Subtraction operation");
           RESULT = new BinaryOpNode(e1, "-", e2);
        :}
        |
        expr:e1 TIMES expr:e2
        {:
           System.out.println("Multiplication operation");
           RESULT = new BinaryOpNode(e1, "*", e2);
        :}
        |
        expr:e1 DIVIDE expr:e2
        {:
           System.out.println("Division operation");
           RESULT = new BinaryOpNode(e1, "/", e2);
        :}
        |
        LPAREN expr:e RPAREN
        {:
           System.out.println("Parenthesized expression");
           RESULT = e;
        :}
        |
        NUMBER:n
        {:
           System.out.println("Number: " + n);
           RESULT = new NumberNode((Integer)n);
        :}
        |
        ID:name
        {:
           checkVariable((String)name);
           System.out.println("Variable reference: " + name);
           RESULT = new VariableNode((String)name);
        :}
        |
        TRUE:t
        {:
           System.out.println("Boolean literal: true");
           RESULT = new BooleanNode(true);
        :}
        |
        FALSE:f
        {:
           System.out.println("Boolean literal: false");
           RESULT = new BooleanNode(false);
        :}
        ;