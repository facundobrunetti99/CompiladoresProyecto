package org.example;
import java_cup.runtime.*;
import java.util.*;
import org.example.ast.*;
import org.example.semantic.symboltable.SymbolTable;

parser code {:

    private SymbolTable symbolTable = new SymbolTable();

    public SymbolTable getSymbolTable() {
        return symbolTable;
    }

    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error Sintáctico");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" en línea " + (s.left + 1));
                if (s.right >= 0)
                    m.append(", columna " + (s.right + 1));
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    public void checkVariable(String varName, int line, int column) {
        if (!symbolTable.exists(varName)) {
            System.err.println("Error Semántico en línea " + (line+1) + ", columna " + (column+1) +
                             ": Variable '" + varName + "' no declarada");
            System.exit(1);
        }
    }

    public void addVariable(String varName, String type, int line, int column) {
        if (symbolTable.existsLocal(varName)) {
            System.err.println("Error Semántico en línea " + (line+1) + ", columna " + (column+1) +
                             ": Variable '" + varName + "' ya declarada en este scope");
            System.exit(1);
        }
        if (symbolTable.declare(varName, type, line, column)) {
            System.out.println("✓ Variable '" + varName + "' declarada como " + type +
                             " (línea " + (line+1) + ")");
        }
    }

    public void enterScope(String scopeName) {
        symbolTable.enterScope(scopeName);
        System.out.println("  → Entrando a scope: " + scopeName);
    }

    public void exitScope() {
        System.out.println("  ← Saliendo de scope: " + symbolTable.getCurrentScope().getScopeName());
        symbolTable.exitScope();
    }

:};

/* Terminales */
terminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN;
terminal           LBRACE, RBRACE, ASSIGN;
terminal           INT, BOOL, VOID, MAIN, RETURN;
terminal           IF, ELSE, WHILE;
terminal           EQ, NE, LT, GT, LE, GE;
terminal           TRUE, FALSE;
terminal Integer   NUMBER;
terminal String    ID;

/* No terminales */
non terminal ProgramNode           program;
non terminal String                return_type;
non terminal MainFunctionNode      main_function;
non terminal List<DeclarationNode> declaration_list;
non terminal DeclarationNode       declaration;
non terminal List<StatementNode>   statement_list;
non terminal StatementNode         statement;
non terminal AssignmentNode        assignment;
non terminal ReturnNode            return_stmt;
non terminal IfNode                if_stmt;
non terminal WhileNode             while_stmt;
non terminal ExpressionNode        expr;
non terminal ExpressionNode        comparison;

/* Precedencia */
precedence left EQ, NE;
precedence left LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence nonassoc ELSE;

/* Gramática */

program ::= return_type:rt main_function:mf
{:
    ProgramNode prog = new ProgramNode(rt, mf);
    System.out.println("\n✓ Programa parseado exitosamente con tipo de retorno: " + rt);
    parser.symbolTable.printSymbolTable();
    parser.symbolTable.printStatistics();
    RESULT = prog;
:}
;

return_type ::= INT   {: RESULT = "int"; :}
              | BOOL {: RESULT = "bool"; :}
              | VOID {: RESULT = "void"; :}
;

main_function ::= MAIN LPAREN RPAREN LBRACE declaration_list:dl statement_list:sl RBRACE
{:
    System.out.println("✓ Función main parseada");
    RESULT = new MainFunctionNode(dl, sl);
:}
;

declaration_list ::= declaration_list:dl declaration:d
{:
    if (dl == null) dl = new ArrayList<DeclarationNode>();
    dl.add(d);
    RESULT = dl;
:}
| /* empty */
{: RESULT = new ArrayList<DeclarationNode>(); :}
;

declaration ::= INT ID:name SEMI
{:
    parser.addVariable(name, "int", nameleft, nameright);
    RESULT = new VariableDeclarationNode("int", name);
:}
| BOOL ID:name SEMI
{:
    parser.addVariable(name, "bool", nameleft, nameright);
    RESULT = new VariableDeclarationNode("bool", name);
:}
;

statement_list ::= statement_list:sl statement:s
{:
    if (sl == null) sl = new ArrayList<StatementNode>();
    sl.add(s);
    RESULT = sl;
:}
| /* empty */
{: RESULT = new ArrayList<StatementNode>(); :}
;

statement ::= assignment:a    {: RESULT = a; :}
            | return_stmt:r   {: RESULT = r; :}
            | if_stmt:i       {: RESULT = i; :}
            | while_stmt:w    {: RESULT = w; :}
;

assignment ::= ID:name ASSIGN expr:e SEMI
{:
    parser.checkVariable(name, nameleft, nameright);
    System.out.println("✓ Asignación a variable: " + name);
    RESULT = new AssignmentNode(name, e);
:}
;

return_stmt ::= RETURN expr:e SEMI
{:
    System.out.println("✓ Return con expresión");
    RESULT = new ReturnNode(e);
:}
| RETURN SEMI
{:
    System.out.println("✓ Return sin expresión");
    RESULT = new ReturnNode(null);
:}
;

if_stmt ::= IF LPAREN comparison:c RPAREN LBRACE statement_list:then_stmts RBRACE
            ELSE LBRACE statement_list:else_stmts RBRACE
{:
    System.out.println("✓ IF-ELSE completo");
    RESULT = new IfNode(c, then_stmts, else_stmts);
:}
| IF LPAREN comparison:c RPAREN LBRACE statement_list:then_stmts RBRACE
{:
    System.out.println("✓ IF sin ELSE");
    RESULT = new IfNode(c, then_stmts, null);
:}
;

while_stmt ::= WHILE LPAREN comparison:c RPAREN LBRACE statement_list:body RBRACE
{:
    System.out.println("✓ WHILE loop");
    RESULT = new WhileNode(c, body);
:}
;

comparison ::= expr:e1 EQ expr:e2
{:
    System.out.println("  Comparación: ==");
    RESULT = new ComparisonNode(e1, "==", e2);
:}
| expr:e1 NE expr:e2
{:
    System.out.println("  Comparación: !=");
    RESULT = new ComparisonNode(e1, "!=", e2);
:}
| expr:e1 LT expr:e2
{:
    System.out.println("  Comparación: <");
    RESULT = new ComparisonNode(e1, "<", e2);
:}
| expr:e1 GT expr:e2
{:
    System.out.println("  Comparación: >");
    RESULT = new ComparisonNode(e1, ">", e2);
:}
| expr:e1 LE expr:e2
{:
    System.out.println("  Comparación: <=");
    RESULT = new ComparisonNode(e1, "<=", e2);
:}
| expr:e1 GE expr:e2
{:
    System.out.println("  Comparación: >=");
    RESULT = new ComparisonNode(e1, ">=", e2);
:}
| expr:e
{:
    RESULT = e;
:}
;

expr ::= expr:e1 PLUS expr:e2
{:
    System.out.println("  Operación: +");
    RESULT = new BinaryOpNode(e1, "+", e2);
:}
| expr:e1 MINUS expr:e2
{:
    System.out.println("  Operación: -");
    RESULT = new BinaryOpNode(e1, "-", e2);
:}
| expr:e1 TIMES expr:e2
{:
    System.out.println("  Operación: *");
    RESULT = new BinaryOpNode(e1, "*", e2);
:}
| expr:e1 DIVIDE expr:e2
{:
    System.out.println("  Operación: /");
    RESULT = new BinaryOpNode(e1, "/", e2);
:}
| LPAREN expr:e RPAREN
{:
    RESULT = e;
:}
| NUMBER:n
{:
    RESULT = new NumberNode(n);
:}
| ID:name
{:
    parser.checkVariable(name, nameleft, nameright);
    RESULT = new VariableNode(name);
:}
| TRUE
{:
    RESULT = new BooleanNode(true);
:}
| FALSE
{:
    RESULT = new BooleanNode(false);
:}
;